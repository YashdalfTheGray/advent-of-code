// This file is generated by the create-files script in ../utils.
// Day 8 part 2
// https://adventofcode.com/2021/day/8#part2
// input: day8/input.txt

enum Segment {
  Top,
  TopLeft,
  TopRight,
  Middle,
  BottomLeft,
  BottomRight,
  Bottom,
}

type SegmentDisplayState = {
  [key in 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 0]: string;
};
type ReverseSegmentDisplayState = {
  [key: string]: keyof SegmentDisplayState;
};
type SegmentToLetterMap = Partial<{
  [key in Segment]: string;
}>;

const firstSetContainsSecond = (str: string, sub: string): boolean => {
  return sub.split('').filter((s) => !str.includes(s)).length === 0;
};

const setDifference = (s1: string, s2: string): string[] => {
  return s1.split('').filter((e) => !s2.includes(e));
};

const dedupe = <T>(arr: T[]): T[] => [...new Set(arr)];

const areSetsOrthogonal = (s1: string, s2: string): boolean => {
  return (
    dedupe(s1.concat(s2).split('')).length ===
    dedupe(s1.split('')).length + dedupe(s2.split('')).length
  );
};

class SevenSegmentExperiment {
  private rawReadings: string[] = [];
  private rawOutput: string[] = [];
  private parsedOutput = 0;
  private intermediateInternalState: SegmentDisplayState;
  private internalState: ReverseSegmentDisplayState;
  private workspaceContext: SegmentToLetterMap = {};

  constructor(entry: string) {
    // split each line into readings and output separated by | and then
    // individual display readings and output digits separated by space
    const [readingsStr, outputStr] = entry.split('|').map((s) => s.trim());
    this.rawReadings = readingsStr.split(' ').map((s) => s.trim());
    this.rawOutput = outputStr.split(' ').map((s) => s.trim());

    // create an map of number to segment representation, we will
    // swap the keys and values to find the output numbers
    this.intermediateInternalState = new Array(10)
      .fill(0)
      .reduce((state, _, i) => ({ ...state, [i]: '' }), {});

    // this will be the reverse map of the one above once
    // analyzeReadings is called.
    this.internalState = {};
  }

  public get rawReadingStrings(): string[] {
    return this.rawReadings;
  }

  public get rawOutputStrings(): string[] {
    return this.rawOutput;
  }

  public parseOutput(): number {
    this.analyzeReadings();

    this.parsedOutput = parseInt(
      this.rawOutput
        .map((s) => {
          // the segments could be in an order that is different than
          // the one we found analyzing the readings so we find the
          // right key from segment representation to number map.
          const theRightKey = Object.keys(this.internalState).find(
            (segmentSet) =>
              segmentSet.split('').sort().join('') ===
              s.split('').sort().join('')
          )!;

          return this.internalState[theRightKey];
        })
        .join(''),
      10
    );

    return this.parsedOutput;
  }

  private analyzeReadings() {
    // Set up the analysis in passes. The first pass, we determine
    // the easy ones, the ones with unique segment representations.
    // Every time after that, we remove the readings that we've
    // already found and then iterate on the remaining ones.

    // find the easy ones like 1, 4, 7, 8
    this.firstParsingPass();
    // 3 is two segments away from 7
    this.secondParsingPass();
    // 9 is one segment away from 3
    this.thirdParsingPass();
    // next up are 2, 5, 6, and 0
    this.fourthParsingPass();

    // build the reverse lookup map
    this.internalState = Object.entries(this.intermediateInternalState).reduce(
      (state, [number, representation]) => ({
        ...state,
        [representation]: parseInt(number),
      }),
      {}
    );
  }

  private firstParsingPass() {
    this.rawReadings.forEach((reading) => {
      switch (reading.length) {
        case 2:
          this.intermediateInternalState[1] = reading;
          break;
        case 3:
          this.intermediateInternalState[7] = reading;
          break;
        case 4:
          this.intermediateInternalState[4] = reading;
          break;
        case 7:
          this.intermediateInternalState[8] = reading;
      }
    });
  }

  private secondParsingPass() {
    this.rawReadings
      .filter((r) => !Object.values(this.intermediateInternalState).includes(r))
      .forEach((reading) => {
        if (
          reading.length === 5 &&
          firstSetContainsSecond(reading, this.intermediateInternalState[7])
        ) {
          this.intermediateInternalState[3] = reading;
        }
      });
  }

  private thirdParsingPass() {
    this.rawReadings
      .filter((r) => !Object.values(this.intermediateInternalState).includes(r))
      .forEach((reading) => {
        if (
          reading.length === 6 &&
          firstSetContainsSecond(reading, this.intermediateInternalState[3])
        ) {
          this.intermediateInternalState[9] = reading;
          this.workspaceContext[Segment.TopLeft] = setDifference(
            this.intermediateInternalState[9],
            this.intermediateInternalState[3]
          )[0];
        }
      });
  }

  private fourthParsingPass() {
    this.rawReadings
      .filter((r) => !Object.values(this.intermediateInternalState).includes(r))
      .forEach((reading) => {
        if (reading.length === 5) {
          const readingSetDifferenceFrom3 = setDifference(
            reading,
            this.intermediateInternalState[3]
          );

          // the segment set difference of 5 and 3 is the top left segment
          if (
            readingSetDifferenceFrom3.length === 1 &&
            readingSetDifferenceFrom3[0] ===
              this.workspaceContext[Segment.TopLeft]
          ) {
            this.intermediateInternalState[5] = reading;
          }
          // the segment set difference of 2 and 3 is the segment set
          // that is orthogonal to the segment set of 9
          if (
            readingSetDifferenceFrom3.length === 1 &&
            areSetsOrthogonal(
              this.intermediateInternalState[9],
              readingSetDifferenceFrom3.join('')
            )
          ) {
            this.intermediateInternalState[2] = reading;
          }
        } else if (reading.length === 6) {
          const readingSetDifferenceFrom8 = setDifference(
            this.intermediateInternalState[8],
            reading
          );

          // the segment set difference of 6 and 8 is the segment set
          // that is orthogonal to the segment set of 1 if the reading
          // is displaying 0
          if (
            areSetsOrthogonal(
              this.intermediateInternalState[1],
              readingSetDifferenceFrom8.join('')
            )
          ) {
            this.intermediateInternalState[0] = reading;
          } else {
            // if it is not orthogonal, that means it contains the
            // TopRight segment, which means the reading is a 6
            this.intermediateInternalState[6] = reading;
          }
        }
      });
  }
}

const d8p2Input = (await Deno.readTextFile('day8/input.txt'))
  .split('\n')
  .filter((l) => !!l)
  .map((l) => new SevenSegmentExperiment(l));

const totalOfAllTheOutput = d8p2Input.reduce(
  (runningTotal, experiment) => runningTotal + experiment.parseOutput(),
  0
);
console.log(`The total of all parsed values is ${totalOfAllTheOutput}`);
