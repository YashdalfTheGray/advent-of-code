// This file is generated by the create-files script in ../utils.
// Day 9 part 2
// https://adventofcode.com/2021/day/9#part2
// input: day9/input.txt

type PointAndHeight = [number, number, number];

const printPointAndHeight = ([x, y, h]: PointAndHeight) => `(${x},${y}):${h}`;

const getAnnotatedNeighbors = (
  grid: number[][],
  x: number,
  y: number
): PointAndHeight[] => {
  const neighbors = [];

  if (x > 0) {
    neighbors.push([x - 1, y, grid[x - 1][y]]);
  }
  if (x < grid.length - 1) {
    neighbors.push([x + 1, y, grid[x + 1][y]]);
  }
  if (y > 0) {
    neighbors.push([x, y - 1, grid[x][y - 1]]);
  }
  if (y < grid[0].length - 1) {
    neighbors.push([x, y + 1, grid[x][y + 1]]);
  }

  return neighbors as PointAndHeight[];
};

const getLowPoints = (grid: number[][]): PointAndHeight[] => {
  const lowPoints = [];

  for (let y = 0; y < grid.length; y++) {
    for (let x = 0; x < grid[y].length; x++) {
      const numbersToCheck = getAnnotatedNeighbors(grid, y, x).map(
        ([_, __, n]) => n
      );

      if (numbersToCheck.every((n) => n > grid[y][x])) {
        lowPoints.push([y, x, grid[y][x]]);
      }
    }
  }

  return lowPoints as PointAndHeight[];
};

// this function uses bfs to find points that are bordered by
// 9s on all sides or are at the end of the grid
function getBasinsOfLowPoints(
  grid: number[][],
  lowPoint: PointAndHeight,
  pointSet = new Set([printPointAndHeight(lowPoint)])
) {
  const pointProcessingQueue = [lowPoint];

  while (pointProcessingQueue.length > 0) {
    const [x, y, _] = pointProcessingQueue.shift()!;
    const neighborPoints = getAnnotatedNeighbors(grid, x, y);

    neighborPoints.forEach(([nx, ny, nvalue]) => {
      if (
        nvalue !== 9 &&
        !pointSet.has(printPointAndHeight([nx, ny, nvalue]))
      ) {
        pointProcessingQueue.push([nx, ny, nvalue]);
        pointSet.add(printPointAndHeight([nx, ny, nvalue]));
      }
    });
  }

  return pointSet;
}

const d9p2Input = (await Deno.readTextFile('day9/input.txt'))
  .split('\n')
  .filter((l) => !!l);

const grid = d9p2Input.map((line) =>
  line.split('').map((c) => parseInt(c, 10))
);

const lowPoints = getLowPoints(grid);

const lowPointBasins = [
  ...lowPoints.map((lp) => getBasinsOfLowPoints(grid, lp)),
].sort((a, b) => b.size - a.size);

const sizeOf3LargestBasins = lowPointBasins
  .slice(0, 3)
  .map((bs) => bs.size)
  .reduce((product, size) => product * size, 1);

console.log('\n');
console.log(
  `The product of the sizes of the three largest basins is ${sizeOf3LargestBasins}`
);
